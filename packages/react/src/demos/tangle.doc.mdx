import {Terminal} from './Screen.tsx';

# Tangle
This is the documentation page for _Tangle_, _Twine_’s compiler. This documentation is partitioned in five: _**part o**_ presents an overview of the _Twine_ language. _**part i**_ covers the mathematical background necessary for understanding _Tangle_’s architecture. _**part ii**_ provides an overview of the compiler’s API and various implementation details. Finally, _**part iv**_ presents current limitations and plans for future improvements.

:::p1
part o
:::

Twine is a scripting language designed specifically for _Loom_. The language supports variable and function declarations, symbolic computation, array-based computation, and classical object-oriented programming.

## Comments
Single-line comments in Twine start with three hyphens-minus (`“-”`) and terminate on the first newline (the character `“\n”`):

~~~
--- Single-line comments emphasize intermissions.
~~~

Multiline comments start with at least three equals signs (`“=”`) and terminate on at least three equals signs:

```
============================
Following Twine’s emphasis
on readability, we use
multiple “=” signs to call
the reader’s attention.
============================
```

## Variables
Variables are declared with either the _let_ or _var_ keywords. Variables declared with _let_ are immutable – once declared, they are frozen in place, and we may not assign them a new value. Variables declared with _var_, however, are mutable.

For example, this is permissible:

~~~ts
var y = 12;
y = 11;
~~~

However, this will trigger an environment error, since `y` is immutable:

~~~ts
let y = 3.14;
y = 5;
~~~

Following the C tradition, statements are delimited by semicolons.

<Terminal source={`var y = 8;
y = 10;
print y;`}/>

### Valid Identifiers
A lexeme will be interpreted as a variable name only if all of the following conditions are satisfied:

1. The lexeme starts with an ASCII Latin character (lower- or upper-case), the underscore character (`“_”`) or a dollar sign (`“$”`).
2. The lexeme ends with an ASCII Latin character (lower- or upper-case), an ASCII digit (the Hindu-Arabic numerals `“0”` through `“9”`), an underscore character (`“_”`), or a dollar sign (`“$”`).
3. The lexeme is not a reserved word.





## Types
Twine recognizes the following core types by default. These types are outlined below, with their documentation symbols parenthesized:

:::hstack
- :u[__Nonalgebraics__]
- string ${\mathbb{S}}$
- boolean ${\mathbb{B}}$
- null ${\texttt{NULL}}$
---
- :u[__Numerics__]
- int ${\mathbb{Z}}$
- float ${\mathbb{F}}$
- rational ${\mathbb{Q}}$
- big-integer ${\mathbb{Z}^{\uparrow}}$
- big-rational ${\mathbb{Q}^{\uparrow}}$
---
- :u[__Functionals__]
- function
- expression
---
- :u[__Gatherings__]
- set
- map
- object
---
- :u[__Sequentials__]
- tuple
- list
- vector
- matrix
- sequence
:::

Each type belongs to a _family_, marked above in bold, underlined headings. Before discussing these families, we must present an overview of each individual type.

### Strings
Strings in Twine are always delimited by double quotes:
~~~ts
let city = "Oconomowoc";
~~~

### Booleans
The set of all Booleans comprises two values, _true_ and _false_:

~~~ts
let aye = true;
let nay = false;
~~~

### Null
The value _null_ denotes nothing, or empty. In contrast to some procedural languages, Twine has no notion of a _void function_. All semantics reduce to some atomic type, _null_ or otherwise.

~~~ts
let empty = null;
~~~

### Numerics
Twine has several numeric types: _int_, _float_, _fraction_, _real_, _rational_, and _complex_.

### Sequentials
_Sequentials_ are well-ordered collections of data. Twine’s core sequential types include _vector_, _matrix_, and _tuple_.

A vector `v`:

~~~ts
let v = [1,2,3,4];
~~~

A matrix `M`:

~~~ts
let M = [
  [1,0,0],
  [0,1,0],
  [0,0,1],
]
~~~

A tuple `t`:
~~~ts
let t = (1,2,3,4)
~~~

### Indexing
All sequentials can be accessed via an _indexing expression_:

<Terminal source={`let x = [8,9,1,2];
let element = x[1];
print element;`}/>

Following mathematical convention, Twine uses 1-based indexing. That is, the first element of a sequential has an index of 1, the second element 2, the third 3, ${\ldots,}$ the ${n^{\text{th}}}$ element ${n.}$

In contrast to JavaScript, Twine does not allow indices exceeding the length of a given sequential. Thus, indexing into an array with a value beyond that of the array’s length will return an error:

<Terminal source={`let x = [8,9,1,2];
let element = x[5];
print element;`}/>

### Vectors
Vectors in Twine are sequences of strictly _ints_ or _floats_. Inserting or initializing any other type into a vector will return a type error. For fixed-length, homogenous sequences of other data types, we use _tuples_. For mixed sequences of arbitrary length, we use _lists_. 

:::aside
The policy of restricting vectors to only integers or floating point numbers stems from how heavily used vectors and matrices are in Loom. Under Twine’s current architecture, vectors are the building blocks of matrices, and operations over matrices, in general, are computationally intensive. They can take significant time and memory to perform. Allowing non-homogenous, arbitrary length vectors requires many more checks at runtime, yielding an increased risk of poor performance. 
:::

Vectors are initialized with square brackets:

<Terminal source={`let x = [1,2,3,4];
print x;`}/>

## Branching Statements
Twine provides the standard `if-else` construct for branching:

<Terminal source={`
var x = 5;
if x < 10 {
  x = 4;
} else {
  x = 8;
}
print x;
`} height={"200px"}/>

Like Rust and other modern languages, the if-block’s necessary condition need not be surrounded by parentheses. However, a left-brace is required to demarcate the consequent’s start. The else branch doesn’t require braces, but it’s best to do so for readability.

## Functions
Functions are declared with the `fn` keyword, followed by an identifier, and a parenthesized argument list. If the function’s body comprises a single statement, then the assignment operator (`=`) may follow the list. Otherwise, braces are required to indicate a block of statements:

<Terminal source={`fn f(x) = x^2;
print f(5);
fn g(x) {
  let k = 1/2;
  return x * k;
}
print g(6);`} height={"210px"}/>


## Classes
Twine supports classical object-oriented programming (OOP) via classes.[^classical-oop]

[^classical-oop]: By _classical_, we mean the approach taken by _Simula_, _Smalltalk_, and its descendants. _See_ [_**jeff sutherland**_, _A History of Object-Oriented Programming Languates and their Impact on Program Design and Software Development_ 2 (1999)](http://jeffsutherland.com/papers/Rans/OOlanguages.pdf).

<Terminal source={`
class Circle {
  callThyself() {
    print "circle!";
  }
}
let circle1 = Circle(5);
circle1.callThyself();
`} height={"200px"}/>

Syntactically, a class in _Twine_ is a collection of functions. Semantically, a class is a bundle of _properties_, where each property is mapped to by a unique _field_. Above, the `Circle` class comprises three fields – `def`, `diameter`, and `radius` – and two properties: (1) `def` maps to `null` (with the side-effect of defining properties bound to the `Circle` instance’s `this` reference), and (2) both `diameter` and `radius` map to numerics.

### `def` and `this`
Like other OOP languages, class instances in Twine have a _this_ reference:


<Terminal source={`
class Box {
  def(length, width, height) {
    this.length = length;
    this.width = width;
    this.height = height;
  }
  volume() {
    return this.length * this.width * this.height;
  }
}
let box1 = Box(3,5,2);
print box1.volume();
`} height={"320px"}/>

Above, we see that the the `Box` class consists of three properties, `length`, `width`, and `height`. These properties are initialized with the `def` method (what might be called a _constructor_ in other OOP languages). All class instances in Twine have a `def` method for initializing their properties.

:::p1
part i
:::

This part introduces the basic mathematical background necessary to understanding the compiler’s architecture. Readers familiar with the outlined topics should proceed to Part II.

## Logic
The following symbols are used extensively throughout the documentation.

| Symbol      | Semantic                 | Example Usage                          |
| ----------- | ------------------------ | -------------------------------------- |
| ${\land}$   | Logical _and_            | ${a \land b}$ (“${a}$ and ${b}$”)      |
| ${\lor}$    | Logical _or_             | ${a \lor b}$ (“${a}$ or ${b}$”)        |
| ${\neg}$    | Logical _not_            | ${\neg x}$ (“not ${x}$”)               |
| ${\exist}$  | _Existence_ predicate    | ${\exist x}$ (“there exists an ${x}$”) |
| ${\forall}$ | _Universality_ predicate | ${\forall x}$ (“for all ${x}$”)        |

## Set Theory
In Twine, the word _object_ refers to any entity that may be persisted in computer memory. We refer to an unordered collection of such entities with the word _set_.

:::definition
### Set
A _set_ is a collection of objects. By convention, we denote sets with upper-case Latin characters, and objects with lower-case Latin characters. Should a set comprise many elements, we use _ellipses_ (${\ldots}$) to denote the fact.
:::

__Example.__ The set ${S = \set{1, 10}}$ is a set comprising two objects, 1 and 10.

__Example.__ The set ${A = \set{1, 2, \ldots, 9, 10}}$ comprises 10 objects, the numbers ${1}$ through ${10.}$

:::definition
### Common Sets
We reserve the following symbols to denote particular sets:

| Symbol         | Set                        |
| -------------- | -------------------------- |
| ${\natnums}$   | The set of natural numbers |
| ${\Z}$         | The set of integers        |
| ${\mathbb{Q}}$ | The set of rationals       |
| ${\R}$         | The set of reals           |
| ${\Complex}$   | The set of complex numbers |
:::



:::definition
### Member
Given a set ${S,}$ if ${S}$ contains an object ${x,}$ we say that ${x}$ is a _member of_ ${S,}$ and write ${x \in S.}$ If ${x}$ is _not_ a member of ${S,}$ we write ${x \notin S.}$
:::

:::definition
### Empty Set
The _set_ containining no objects is called _the empty set_, denoted ${\varnothing.}$
:::

:::definition
### Strict Subset
Given sets ${A}$ and ${B,}$ if every element of ${A}$ is an element of ${B,}$ we say that ${A}$ is a _strict subset_ of ${B,}$ and write ${A \subset B.}$ 
:::

## Polynomials
Polynomials are particularly important in Twine, as they comrpise the bedrock of approximation.

:::definition
### Single-variable Polynomial
A _single-variable polynomial_ is an expression ${u}$ of the form:

$$
  u = a_nx^n + a_{n-1}x^{n-1} + \ldots + a_1 + a_0,
$$

where ${x}$ is a _variable_, and each ${a}$ is a _rational number coefficient_. Where ${a_n \neq 0,}$ the coefficient ${a_n}$ is called the _leading cofficient_ of ${u,}$ and ${n}$ is called its _degree_.
:::


:::p1
part ii
:::

This part of the documentation provides an overview of _Tangle_’s API, followed by summaries of its implementation details.

## Auxiliary Functions
_Tangle_ relies on various standalone helper functions. These functions are presented below.

### Numeric Functions
_Numeric functions_ are those that perform purely numeric computations.

#### rem
Given two numbers, ${a}$ and ${b,}$ returns the signed remainder of ${a}$ and ${b.}$ The function is equivalent to writing `a % b`.

:::tbl
| Parameters               | Returns  |
| ------------------------ | -------- |
| `(a: number, b: number)` | `number` |
:::

#### mod
Returns the remainder of ${a}$ and ${b}$ (i.e., ${a \bmod b}$). The function is equivalent to writing `((a % b) + b) % b`.

:::tbl
| Parameters               | Returns  |
| ------------------------ | -------- |
| `(a: number, b: number)` | `number` |
:::

#### quot
Returns the integer quotient of integers ${a}$ and ${b}$ (i.e., ${\lfloor a/b \rfloor}$).

:::tbl
| Parameters               | Returns  |
| ------------------------ | -------- |
| `(a: number, b: number)` | `number` |
:::

#### gcd 
Returns the greatest common divisor of integers ${a}$ and ${b.}$

:::tbl
| Parameters               | Returns  |
| ------------------------ | -------- |
| `(a: number, b: number)` | `number` |
:::

#### xgcd
Returns a triple corresponding to the result of the extended Euclidean algorithm.

:::tbl
| Parameters             | Returns                    |
| ---------------------- | -------------------------- |
| `(a:number, b:number)` | `[number, number, number]` |
:::


