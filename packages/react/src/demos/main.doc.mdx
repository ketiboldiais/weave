import { ForceGraph1 } from './graph.demo.tsx';
import { Tree1, Tree2 } from './tree.demo.tsx';
import { Tile } from '../components/tile.tsx';
import { Plot1, Plot2 } from './plot.demo.tsx';
import { Path1 } from './path.demo.tsx';
import { Codeblock } from '../components/codeblock.tsx';

# Loom

This is the documentation page for Loom, a module of various graphics algorithms. Some examples:

<Tile rows={1} cols={2}>
<figure>
<ForceGraph1 />
<figcaption>Graph drawn with a variation of the Eades algorithm.</figcaption>
<Codeblock>
~~~tsx
import {
  forceSpace,
  graph
} from "@weave/loom";
import { Figure } from "./figure.tsx";

const d = forceSpace(graph({
  a: ["b"],
  b: ["c", "d"],
  c: ["e"],
})).w(200)
  .h(200)
  .x(-5,5)
  .y(-5,5)
  .figure();

export const ForceGraph1 = () => {
  return <Figure of={d} />;
};
~~~
</Codeblock>
</figure>

<figure>
<Tree1 />
<figcaption>M-way tree drawn with the Buccheim-Unger-Leipert algorithm.</figcaption>
<Codeblock>
~~~tsx
import {
  leaf,
  subtree,
  tree
} from "@weave/loom";
import { Figure } from "./figure.tsx";

const tree1 = tree("a").nodes([
  subtree("d").nodes([
    leaf("g"), 
    leaf("j"), 
    leaf("l"), 
    leaf("m")
  ]),
  subtree("c").nodes([
    leaf("f"), 
    leaf("i")
  ]),
  subtree("b").nodes([
    leaf("e"), 
    leaf("h"), 
    leaf("k")
  ]),
]).x(-6, 6)
  .y(-2, 0)
  .w(300)
  .h(200)
  .ala("buccheim-unger-leipert")
  .figure();

export const Tree1 = () => {
  return <Figure of={tree1} />;
};
~~~
</Codeblock>
</figure>

<figure>
<Plot1 />
<figcaption>Plot of $f(x) = x^3 - 3$.</figcaption>
<Codeblock>
~~~tsx
import {
  axis,
  plot,
  plane
} from "@weave/loom";
import { Figure } from "./figure.tsx";

const plot1 = plane([
  axis("x").ticks(11),
  axis("y").ticks(11).hide("zero"),
  plot('f(x) = (x^3) - 3'),
]).margin(10,10)
  .w(300)
  .h(300)
  .gridlines("xy")
  .figure();

export const Plot1 = () => {
  return <Figure of={plot1} />
};
~~~
</Codeblock>
</figure>

<figure>
<Path1 />
<figcaption>Geometries with matrix transformations</figcaption>
<Codeblock>
~~~tsx
import {
  color,
  rect,
  plane,
} from "@weave/loom";
import { Figure } from "./figure.tsx";

const coral = color('coral');
const yg = color('yellowgreen');
const path1 = plane([
  rect(2,4).fill(coral),
  rect(2,4).fill(coral.compliment())
    .opacity(0.5)
    .rotate('45deg'),
  rect(2,4).fill(yg)
    .opacity(0.5)
    .shearX(2),
]).margin(10, 10)
  .w(300)
  .h(300)
  .gridlines("xy").figure();

export const Path1 = () => {
  return <Figure of={path1} />;
};
~~~
</Codeblock>
</figure>

<figure>
<Plot2 />
<figcaption>Polar plot of $s(t) = \cos(t)\sin(t)$.</figcaption>
<Codeblock>
~~~tsx
import {
  axis,
  plot,
  plane
} from "@weave/loom";
import { Figure } from "./figure.tsx";

const plot2 = plane([
  polar("s(t) = cos(t) * sin(t)"),
]).margin(10, 10)
  .w(300)
  .h(300)
  .gridlines("xy")
  .figure();

export const Plot2 = () => {
  return <Figure of={plot2} />;
};
~~~
</Codeblock>
</figure>



<figure>
<Tree2 />
<figcaption>Binary search tree drawn with the Reingold-Tilford algorithm, its breadth-first traversal annotated in green.</figcaption>
<Codeblock>
~~~tsx
import {
  bst,
  leaf,
  subtree,
  tree
} from "@weave/loom";
import { Figure } from "./figure.tsx";

const greenline = (
  line: Line
) => line
  .stroke('seagreen')
  .weight(1.2);

const bst1 = bst([10, 6, 15, 3, 8, 20])
  .id((d) => d)
  .draw()
  .edges("bfs", greenline)
  .x(-2, 2)
  .y(-2, 0)
  .w(250).h(200)
  .ala("reingold-tilford")
  .figure();

export const Tree2 = () => {
  return <Figure of={bst1} />;
};
~~~
</Codeblock>
</figure>
</Tile>
