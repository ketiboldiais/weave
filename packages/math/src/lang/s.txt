// @ts-nocheck
// =====================================================================
// § - Parse Function
// =====================================================================

const parse = (input: string) => {
  /**
   * Parses a scientific number.
   */
  const scientific: Parslet = (prev) => {
    const lex = prev.lex;
    if (!prev.is("sci")) {
      return state.err(expected("scientific number", lex), "SCI");
    }
    const [n, d] = lex.split("E");
    const base = Number.isInteger(+n) ? int(n) : float(n);
    const exp = binary(int("10"), "^", int(d));
    return state.ok(binary(base, "*", exp));
  };

  const prefix: Parslet = (op) => {
    if (!op.unary()) {
      return state.err(`Expected unary operator`, "unary-prefix");
    }
    const p = precof(op.type);
    return expr(p).chain((n) => state.ok(unaryPrefix(op.type, n)));
  };

  const postfix: Parslet = (op, node) => {
    if (!op.unary()) {
      return state.err(`Expected unary postfix`, "unary-postfix");
    }
    return state.ok(unaryPostfix(op.type, node));
  };

  /**
   * Parses a rational number.
   */
  const rational: Parslet = (prev) => {
    const lex = prev.lex;
    if (!prev.is("frac")) {
      return state.err(expected("RATIO", lex), "rational");
    }
    const [n, d] = lex.split("|");
    return state.ok(ratio(+n, +d));
  };

  /**
   * Parses a binary expression.
   */
  const infix: Parslet = (op, node) => {
    if (!op.arithmetic()) {
      return state.err(`Expected arithmetic operator.`, "infix");
    }
    const p = precof(op.type);
    return expr(p).chain((n) => {
      return state.ok(binary(node, op.type, n));
    });
  };

  const assign: Parslet = (_, node) => {
    if (!isSymbol(node)) {
      return state.err(`Invalid assignment target`, "assign");
    }
    return expr().chain((n) => state.ok(assignment(node.value, n)));
  };

  /**
   * Parses a relational expression.
   */
  const compare: Parslet = (op, node) => {
    if (!op.relational()) {
      return state.err(`Expected relational operator`, `compare`);
    }
    const p = precof(op.type);
    return expr(p).chain((n) => {
      return state.ok(relation(node, op.type, n));
    });
  };
  const primary = () => {
    const innerExpr = expr();
    if (innerExpr.isLeft()) return innerExpr;
    state.next();
    const out = innerExpr.chain((n) => state.ok(group(n)));
    return out;
  };
  const comlist = () => {
    const elements: Expr[] = [];
    do {
      const e = expr();
      if (e.isLeft()) return e;
      elements.push(e.unwrap());
    } while (state.nextIs(","));
    return right(elements);
  };
  const native: Parslet = (op) => {
    const lex = op.lex;
    if (!state.isNative(lex)) {
      return state.err(`Unexpected native call`, "native");
    }
    if (!state.nextIs("(")) {
      return state.err(`Expected “(” to open arguments`, "native");
    }
    let args: Expr[] = [];
    if (!state.check(")")) {
      const arglist = comlist();
      if (arglist.isLeft()) return arglist;
      args = arglist.unwrap();
    }
    if (!state.nextIs(")")) {
      return state.err(expected(")", state.peek.lex), "native");
    }
    return state.ok(nativeCall(lex, args));
  };

  const callExpr: Parslet = (_, lastnode) => {
    const callee = lastnode;
    let args: Expr[] = [];
    if (!state.check(")")) {
      const arglist = comlist();
      if (arglist.isLeft()) return arglist;
      args = arglist.unwrap();
    }
    if (!state.nextIs(")")) {
      return state.err(`Expected “)” to close arguments`, "call");
    }
    return state.ok(call(callee, args));
  };

  const __o = -1;
  const LOWEST = 0;
  const ASSIGN = 10;
  const ATOM = 20;
  const RELATION = 40;
  const SUM = 50;
  const PRODUCT = 60;
  const QUOTIENT = 70;
  const POWER = 80;
  const CALL = 90;
  const rules: PSpec = {
    "(": [primary, callExpr, CALL],
    ")": [__, __, __o],
    ":": [__, __, __o],
    ";": [__, __, __o],
    "{": [__, __, __o],
    "}": [__, __, __o],
    "[": [__, __, __o],
    "]": [__, __, __o],
    ",": [__, __, __o],
    ".": [__, __, __o],
    "=": [__, assign, ASSIGN],
    call: [native, __, CALL],
    "+": [prefix, infix, SUM],
    "-": [prefix, infix, SUM],
    "*": [__, infix, PRODUCT],
    "^": [__, infix, POWER],
    "/": [__, infix, PRODUCT],
    "%": [__, infix, QUOTIENT],
    rem: [__, infix, QUOTIENT],
    div: [__, infix, QUOTIENT],
    mod: [__, infix, QUOTIENT],
    "<": [__, compare, RELATION],
    ">": [__, compare, RELATION],
    "!=": [__, compare, RELATION],
    "==": [__, compare, RELATION],
    "<=": [__, compare, RELATION],
    ">=": [__, compare, RELATION],
    "!": [__, postfix, CALL],
    begin: [__, __, __o],
    end: [__, __, __o],
    int: [atom, __, ATOM],
    float: [atom, __, ATOM],
    bool: [atom, __, ATOM],
    sym: [atom, __, ATOM],
    string: [atom, __, ATOM],
    nil: [atom, __, ATOM],
    frac: [rational, __, ATOM],
    sci: [scientific, __, ATOM],
    complex: [__, __, __o],
    EMPTY: [__, __, __o],
    ERR: [__, __, __o],
    EOF: [__, __, __o],
    fn: [__, __, __o],
    let: [__, __, __o],
    while: [__, __, __o],
    for: [__, __, __o],
    if: [__, __, __o],
    else: [__, __, __o],
    return: [__, __, __o],
  };

  const BLOCK = () => {
    const stmts: Stmt[] = [];
    while (!state.check("end") && !state.atEnd()) {
      const stmt = STMT();
      if (stmt.isLeft()) return stmt;
      stmts.push(stmt.unwrap());
    }
    if (!state.nextIs("end")) {
      return state.err(`expected closing “end”`, "block");
    }
    return state.ok(block(stmts));
  };

  const FN = () => {
    const name = state.next();
    if (!name.is("sym")) {
      return state.err(`Expected function name`, "fn");
    }
    if (!state.nextIs("(")) {
      return state.err(`Expected “(” to open params`, "fn");
    }
    let params: string[] = [];
    if (!state.peek.is(")")) {
      const elems = comlist();
      if (elems.isLeft()) return elems;
      const ps = elems.unwrap();
      for (let i = 0; i < ps.length; i++) {
        const e = ps[i];
        if (!isSymbol(e)) {
          return state.err(`Expected parameter symbol`, "fn");
        }
        params.push(e.value);
      }
    }
    if (!state.nextIs(")")) {
      return state.err(`Expected “)” to close params`, "fn");
    }
    if (!state.nextIs("=")) {
      return state.err(`Expected assign “=” after params`, "fn");
    }
    const body = STMT();
    if (body.isLeft()) return body;
    return state.ok(fnStmt(name.lex, params, body.unwrap()));
  };

  /**
   * Parses a variable definition
   * @example
   * let y = 2;
   */
  const LET = () => {
    // let eaten in statement
    const name = state.next();
    if (!name.is("sym")) {
      return state.err(`Expected symbol`, "let");
    }
    if (!state.nextIs("=")) {
      return state.err(`Expected assign “=”`, "let");
    }
    const init = EXPR();
    if (init.isLeft()) return init;
    const value = init.unwrap().expression;
    return state.ok(varStmt(name.lex, value));
  };
  const EXPR = () => {
    const out = expr();
    if (out.isLeft()) return out;
    if (state.nextIs(";") || state.implicitSemicolonOk()) {
      return state.ok(exprStmt(out.unwrap()));
    }
    return state.err(`Expected “;” to end statement`, "expression");
  };

  const IF = () => {
    // if eaten by STMT
    const condition = expr();
    if (condition.isLeft()) return condition;
    if (!state.nextIs("begin")) {
      return state.err(`Expected “begin” after condition`, "if");
    }
    const ifBranch = BLOCK();
    if (ifBranch.isLeft()) return ifBranch;
    let elseBranch: Stmt = exprStmt(nil());
    if (state.nextIs("else")) {
      const _else = STMT();
      if (_else.isLeft()) return _else;
      elseBranch = _else.unwrap();
    }
    return state.ok(ifStmt(condition.unwrap(), ifBranch.unwrap(), elseBranch));
  };

  const STMT = (): Left<Err> | Right<Stmt> => {
    if (state.nextIs("begin")) return BLOCK();
    if (state.nextIs("let")) return LET();
    if (state.nextIs("fn")) return FN();
    if (state.nextIs("if")) return IF();
    return EXPR();
  };
  const program = () => {
    const stmts: Stmt[] = [];
    while (!state.atEnd()) {
      const stmt = STMT();
      if (stmt.isLeft()) {
        return failure(stmt.unwrap());
      } else {
        stmts.push(stmt.unwrap());
      }
    }
    return success(stmts);
  };
  const parseExpression = () => {
    state.next();
    return expr();
  };
  const run = () => {
    state.next(); // prime the state
    return program();
  };
  return {
    run,
    tokenize: () => state.tokens,
    parseExpression,
  };
};

const src = `
cos(x) - 1
`;
const k = parse(src).run();

print(treeof(k));

type REC = Record<
  AlgebraicAtom,
  Record<ArithmeticOperator, Record<AlgebraicAtom, {}>>
>;

/*
const algop2: REC = {
  int: {
    "+": {
      int: (a: INT, b: INT) => int(a.value + b.value),
      float: (a: INT, b: FLOAT) => float(a.value + b.value),
      frac: {},
      sym: {},
      complex: {},
    },
    "-": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "/": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "*": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "^": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "%": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "div": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "rem": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "mod": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
  },
  float: {
    "+": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "-": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "/": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "*": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "^": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "%": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "div": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "rem": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "mod": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
  },
  frac: {
    "+": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "-": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "/": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "*": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "^": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "%": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "div": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "rem": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "mod": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
  },
  sym: {
    "+": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "-": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "/": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "*": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "^": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "%": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "div": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "rem": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "mod": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
  },
  complex: {
    "+": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "-": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "/": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "*": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "^": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "%": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "div": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "rem": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
    "mod": {
      int: {},
      float: {},
      frac: {},
      sym: {},
      complex: {},
    },
  },
};
*/

import {
  amid,
  choice,
  latin,
  list,
  lit,
  many,
  maybe,
  P,
  regex,
  thunk,
} from "@weave/reed";

const times = lit("->").map<"->">((_) => "->");
const plus = lit("&").map<"&">((_) => "&");
const minus = lit("|").map<"|">((_) => "|");
const tilde = lit("~");
const LETTERS = regex(/^[a-zA-Z_$]/);
const DIGITS = regex(/^\d+/);
const digits = list([LETTERS, maybe(DIGITS)]).map((s) => s.join("")).trim();
const lparen = lit("(");
const rparen = lit(")");
const parend = amid(lparen, rparen);

const divide = lit("/");
type TypeID = string;
type OP = "|" | "&" | "->";
type Term = string;
type TypeExpr = { op: OP; x: Term | TypeExpr; y: Term | TypeExpr };
const binaryExpression = (op: P<TypeExpr>) => (parser: P<TypeExpr>) =>
  list([
    (parser).trim(),
    many(list([(op).trim(), (parser).trim()])),
  ])
    .map(([initialTerm, expressions]) =>
      [initialTerm, ...expressions].reduce((acc, curr) =>
        // @ts-ignore
        Array.isArray(curr) ? { op: curr[0], x: acc, y: curr[1] } : curr
      )
    );

// Typescript can’t handle this recursion at all. Completely loses its mind.
// @ts-ignore
const factor: P<Typex> = thunk(() => choice([digits, parend(expression)]));
// @ts-ignore
const term: P<Typex> = thunk(() => choice([prod, factor]));
// @ts-ignore
const expression = thunk(() => choice([sum, term]));
// @ts-ignore
const sum = binaryExpression(choice([plus, minus]))(term);
// @ts-ignore
const prod = binaryExpression(choice([times, divide]))(factor);
// @ts-ignore
const expr: P<Typex> = many(expression).map((x) => x[0]);

export type Fraction = [[number, number], "fraction"];
const frac = (n: number, d: number): Fraction => [[n, d], "fraction"];
export type Complex = [[number, number], "complex"];
const cpx = (n: number, d: number): Complex => [[n, d], "complex"];
export type Int = [number, "int"];
const int = (n: number) => [n, "int"];
export type Float = [number, "float"];
const float = (n: number): Float => [n, "float"];
export type Numeric = Fraction | Complex | Int | Float;
const isFraction = (n: Numeric): n is Fraction => n[1] === "fraction";
const isComplex = (n: Numeric): n is Complex => n[1] === "complex";
const isInt = (n: Numeric): n is Int => n[1] === "int";
const isFloat = (n: Numeric): n is Float => n[1] === "float";
const D = (n: Numeric | number) => {
  if (typeof n === "number") {
    if (isINT(n)) return 1;
    return toFrac(n)[1];
  }
  const t = n[1];
  // deno-fmt-ignore
  switch (t) {
    case "int": return 1;
    case "float": return toFrac(n[0])[1];
    case "complex": return 1;
    case "fraction": return n[0][1];
  }
};

const N = (n: Numeric | number) => {
  if (typeof n === "number") {
    if (isINT(n)) return N;
    return toFrac(n)[0];
  }
  const t = n[1];
  // deno-fmt-ignore
  switch (t) {
    case "int": return n[0];
    case "float": return toFrac(n[0])[1];
    case "complex": return n[0][0];
    case "fraction": return n[0][1];
  }
};

const R = (n:Numeric|number) => {
  if (typeof n === 'number') return n;
  const t = n[1];
  switch (t) {
    case 'int': return n[0];
    case 'float': return n[0];
    case 'complex': return n[0][1];
    case 'fraction': return (n[0][0])/(n[0][1]);
  }
}
const I = (n:Numeric|number) => {
  if (typeof n === 'number') return n;
  const t = n[1];
  switch (t) {
    case 'int': return 0;
    case 'float': return 0;
    case 'complex': return n[0][1];
    case 'fraction': return 0;
  }
}


export abstract class Expr extends ASTNode {
  constructor(
    type: tt,
    nodeclass: nk.algebraic_expression | nk.nonalgebraic_expression,
  ) {
    super(type, nodeclass);
  }
}
export const isExpr = (node: ASTNode): node is Expr => (
  node.nodeclass === nk.algebraic_expression ||
  node.nodeclass === nk.nonalgebraic_expression
);

export abstract class NonalgebraicExpr extends Expr {
  constructor(type: tt) {
    super(type, nk.nonalgebraic_expression);
  }
}

export class FnCall extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.fnCall(this);
  }
  callee: Expr;
  args: Expr[];
  constructor(callee: Expr, args: Expr[]) {
    super(tt.rparen);
    this.callee = callee;
    this.args = args;
  }
}
export const fnCall = (callee: Expr, args: Expr[]) => (
  new FnCall(callee, args)
);

export class Atom extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.constant(this);
  }
  s: string | null | boolean;
  type: tt.string | tt.null | tt.bool;
  constructor(s: string | null | boolean, type: tt.string | tt.null | tt.bool) {
    super(type);
    this.s = s;
    this.type = type;
  }
}
export const str = (value: string) => (
  new Atom(value, tt.string)
);
export const nil = () => (
  new Atom(null, tt.null)
);

export const bool = (value: boolean) => (
  new Atom(value, tt.bool)
);

export class AssignExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.assign(this);
  }
  name: Sym;
  init: Expr;
  constructor(name: Sym, init: Expr) {
    super(tt.eq);
    this.name = name;
    this.init = init;
  }
}
export const assignment = (name: Sym, init: Expr) => (
  new AssignExpr(name, init)
);

export class LogicalExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.logicExpr(this);
  }
  left: Expr;
  op: Token<BooleanOperator>;
  right: Expr;
  constructor(left: Expr, op: Token<BooleanOperator>, right: Expr) {
    super(op.type);
    this.left = left;
    this.op = op;
    this.right = right;
  }
}
export const logic = (left: Expr, op: Token<BooleanOperator>, right: Expr) => (
  new LogicalExpr(left, op, right)
);

export class RelationExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.relation(this);
  }
  left: Expr;
  op: Token<RelationalOperator>;
  right: Expr;
  constructor(left: Expr, op: Token<RelationalOperator>, right: Expr) {
    super(op.type);
    this.left = left;
    this.op = op;
    this.right = right;
  }
}

export class SetExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.set(this);
  }
  elements: Expr[];
  constructor(elements: Expr[]) {
    super(tt.lbrace);
    this.elements = elements;
  }
}
export const setExpr = (elements: Expr[]) => (
  new SetExpr(elements)
);

export class TupleExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.tuple(this);
  }
  elements: Expr[];
  constructor(elements: Expr[]) {
    super(tt.lbracket);
    this.elements = elements;
  }
}
export const tupleExpr = (elements: Expr[]) => (
  new TupleExpr(elements)
);

export class Group extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.group(this);
  }
  expression: NonalgebraicExpr;
  constructor(expression: NonalgebraicExpr) {
    super(tt.lparen);
    this.expression = expression;
  }
}
export const group = (expr: NonalgebraicExpr) => (
  new Group(expr)
);

export const relation = (
  left: Expr,
  op: Token<RelationalOperator>,
  right: Expr,
) => (
  new RelationExpr(left, op, right)
);

export abstract class AlgebraicExpr extends Expr {
  abstract map<T>(algebra: Algebra<T>): T;
  constructor(type: tt) {
    super(type, nk.algebraic_expression);
  }
  abstract toString(): string;
}

export const sortArgs = (args: AlgebraicExpr[]) => (
  args.sort((a, b) => a.toString() < b.toString() ? -1 : 1)
);

export class Cmpx extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.complex(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.complex(this);
  }
  complex: Complex;
  constructor(c: Complex) {
    super(tt.complex);
    this.complex = c;
  }
  toString(): string {
    return this.complex.toString();
  }
}
export const cmpx = (c: Complex) => (
  new Cmpx(c)
);

export const isComplex = (n: AlgebraicExpr): n is Cmpx => (
  n.kind === tt.complex
);

export class Rational extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.rational(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.rational(this);
  }
  fraction: Fraction;
  constructor(f: Fraction) {
    super(tt.frac);
    this.fraction = f;
  }
  toString(): string {
    return this.fraction.toString();
  }
}
export const rational = (f: Fraction) => (
  new Rational(f)
);

export const isRational = (n: AlgebraicExpr): n is Rational => (
  n.kind === tt.frac
);

export class Float extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.float(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.float(this);
  }
  n: number;
  constructor(n: number) {
    super(tt.float);
    this.n = n;
  }
  toString(): string {
    return `${this.n}`;
  }
  get complex() {
    return complex([this.n, 0]);
  }
  get fraction() {
    return frac(toFrac(this.n));
  }
  get is0() {
    return this.n === 0;
  }
  get is1() {
    return this.n === 1;
  }
}
export const isFloat = (node: ASTNode): node is Float => (
  node.kind === tt.float
);
export const float = (value: string | number) => (
  new Float(+value)
);

export class Integer extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.int(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.int(this);
  }
  toString(): string {
    return `${this.n}`;
  }
  n: number;
  constructor(value: number) {
    super(tt.int);
    this.n = value;
  }
  get complex() {
    return complex([this.n, 0]);
  }
  get fraction() {
    return frac([this.n, 1]);
  }
  get is1() {
    return this.n === 1;
  }
  get is0() {
    return this.n === 0;
  }
}
export const isInteger = (node: ASTNode): node is Integer => (
  node.kind === tt.int
);
export const int = (value: number | string) => (
  new Integer(floor(+value))
);

export class Sym extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.symbol(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.symbol(this);
  }
  toString(): string {
    return this.s;
  }
  s: string;
  type: string;
  constructor(value: string, type: string) {
    super(tt.symbol);
    this.s = value;
    this.type = type;
  }
  equals(other: Sym) {
    return this.s === other.s;
  }
  entype(type: string) {
    return new Sym(
      this.s,
      type,
    );
  }
}
export const sym = (value: string, type: string = "") => (
  new Sym(value, type)
);
export const isSymbol = (node: ASTNode): node is Sym => (
  node.kind === tt.symbol
);

export class AlgebraicGroup extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.algebraicGroup(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.algebraicGroup(this);
  }
  toString(): string {
    return `(${this.expression.toString()})`;
  }
  expression: AlgebraicExpr;
  constructor(expression: AlgebraicExpr) {
    super(tt.lparen);
    this.expression = expression;
  }
}
export const isparend = (n: AlgebraicExpr): n is AlgebraicGroup => (
  n.kind === tt.lparen && n.nodeclass === nk.algebraic_expression
);
export const algebraGroup = (expression: AlgebraicExpr) => (
  new AlgebraicGroup(expression)
);

export class AlgebraicCall<F extends CoreFns = CoreFns> extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.algebraicCall(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.algebraicCall(this);
  }
  toString(): string {
    return `${this.callee}(${this.args.map((v) => v.toString()).join(",")})`;
  }
  callee: F;
  args: AlgebraicExpr[];
  constructor(callee: F, args: AlgebraicExpr[]) {
    super(tt.call);
    this.callee = callee;
    this.args = args;
  }
}

export type CoreFns =
  | "sin"
  | "cos"
  | "tan"
  | "arctan"
  | "+"
  | "-"
  | "!"
  | "*"
  | "neg"
  | "pos";
export const isAlgebraicCall = (n: AlgebraicExpr): n is AlgebraicCall => (
  n.kind === tt.call && n.nodeclass === nk.algebraic_expression
);
export const algebraCall = (callee: CoreFns, args: AlgebraicExpr[]) => {
  return new AlgebraicCall(callee, args);
};
export const flatten = (op: CoreFns, args: AlgebraicExpr[]) => {
  const newargs = [];
  if (op !== "+" && op !== "*") {
    return args;
  }
  for (let i = 0; i < args.length; i++) {
    const n = args[i];
    if (isAlgebraicCall(n) && n.callee === op) {
      n.args.forEach((a) => newargs.push(a));
      continue;
    }
    newargs.push(n);
  }
  return newargs;
};

export type AX = AlgebraicExpr;
export type BinarySum = Binary<AX, tt.plus, AX>;
export type BinaryProduct = Binary<AX, tt.star, AX>;
export type BinaryDiff = Binary<AX, tt.minus, AX>;
export type BinaryQuot = Binary<AX, tt.slash, AX>;
export type BinaryPow = Binary<AX, tt.caret, AX>;

export class Binary<
  A extends AlgebraicExpr = AlgebraicExpr,
  O extends BinaryOperator = BinaryOperator,
  B extends AlgebraicExpr = AlgebraicExpr,
> extends AlgebraicExpr {
  toString(): string {
    return `${this.left.toString()} ${this.op.lex} ${this.right.toString()}`;
  }
  map<T>(algebra: Algebra<T>): T {
    return algebra.binary(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.binary(this);
  }
  toSum() {
    return new AlgebraicCall("+", sortArgs([this.left, this.right]));
  }
  toProduct() {
    return new AlgebraicCall("*", sortArgs([this.left, this.right]));
  }
  left: A;
  op: Token<O>;
  right: B;
  constructor(
    left: A,
    op: Token<O>,
    right: B,
  ) {
    super(op.type);
    this.left = left;
    this.op = op;
    this.right = right;
  }
  isPow(): this is BinaryPow {
    return this.op.is(tt.caret as any);
  }
  isProd(): this is BinaryProduct {
    return this.op.is(tt.star as any);
  }
  isQuot(): this is BinaryQuot {
    return this.op.is(tt.slash as any);
  }
  isDiff(): this is BinaryDiff {
    return this.op.is(tt.minus as any);
  }
  isSum(): this is BinarySum {
    return this.op.is(tt.plus as any);
  }
  static sum(left: AlgebraicExpr, right: AlgebraicExpr) {
    return new Binary(left, tkn(tt.plus, "+", -1), right);
  }
  static product(left: AlgebraicExpr, right: AlgebraicExpr) {
    return new Binary(left, tkn(tt.star, "*", -1), right);
  }
}

export const isBinary = (node: ASTNode): node is Binary => (
  node.nodeclass === nk.algebraic_expression && (
    node.kind === tt.star ||
    node.kind === tt.plus ||
    node.kind === tt.caret ||
    node.kind === tt.slash ||
    node.kind === tt.mod ||
    node.kind === tt.percent
  )
);
export const binex = (
  left: AlgebraicExpr,
  op: Token<BinaryOperator>,
  right: AlgebraicExpr,
) => (
  new Binary(left, op, right)
);

export class Program {
  code: Statement[];
  error: Err | null;
  constructor(code: Statement[], error: Err | null) {
    this.code = code;
    this.error = error;
  }
}
export const success = (code: Statement[]) => (
  new Program(code, null)
);
export const failure = (error: Err) => (
  new Program([], error)
);


export interface Visitor<T> {
  int(node: Integer): T;
  symbol(node: Sym): T;
  float(node: Float): T;
  complex(node: Cmpx): T;
  rational(node: Rational): T;
  constant(node: Atom): T;
  binary(node: Binary): T;
  tuple(node: TupleExpr): T;
  set(node: SetExpr): T;
  relation(node: RelationExpr): T;
  logicExpr(node: LogicalExpr): T;
  algebraicCall(node: AlgebraicCall): T;
  algebraicGroup(node: AlgebraicGroup): T;
  group(node: Group): T;
  fnCall(node: FnCall): T;
  assign(node: AssignExpr): T;
  blockStmt(node: BlockStmt): T;
  exprStmt(node: ExprStmt): T;
  functionStmt(node: FunctionStmt): T;
  ifStmt(node: IfStmt): T;
  varStmt(node: VariableStmt): T;
  loopStmt(node: LoopStmt): T;
}
export type Atomic = Integer | Sym | Float | Cmpx | Rational;
export const isAtom = (node: ASTNode): node is Atomic => (
  node.kind === tt.float ||
  node.kind === tt.int ||
  node.kind === tt.symbol ||
  node.kind === tt.frac ||
  node.kind === tt.complex
);
export interface Algebra<T> {
  int(node: Integer): T;
  float(node: Float): T;
  symbol(node: Sym): T;
  complex(node: Cmpx): T;
  rational(node: Rational): T;
  binary(node: Binary): T;
  algebraicCall(node: AlgebraicCall): T;
  algebraicGroup(node: AlgebraicGroup): T;
}

export abstract class ASTNode {
  abstract accept<T>(visitor: Visitor<T>): T;
  kind: tt;
  nodeclass: nk;
  constructor(type: tt, kind: nk) {
    this.kind = type;
    this.nodeclass = kind;
  }
}

export const algebraic = (node: ASTNode): node is AlgebraicExpr => (
  node.nodeclass === nk.algebraic_expression
);

export abstract class Statement extends ASTNode {
  constructor(type: tt) {
    super(type, nk.statement);
  }
}

export class LoopStmt extends Statement {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.loopStmt(this);
  }
  condition: Expr;
  body: Statement;
  constructor(condition: Expr, body: Statement) {
    super(tt.while);
    this.condition = condition;
    this.body = body;
  }
}

export class IfStmt extends Statement {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.ifStmt(this);
  }
  condition: Expr;
  then: Statement;
  alt: Statement;
  constructor(condition: Expr, then: Statement, alt: Statement) {
    super(tt.if);
    this.condition = condition;
    this.then = then;
    this.alt = alt;
  }
}
export const ifStmt = (condition: Expr, then: Statement, alt: Statement) => (
  new IfStmt(condition, then, alt)
);

export class VariableStmt extends Statement {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.varStmt(this);
  }
  name: Sym;
  init: Expr;
  constructor(name: Sym, init: Expr) {
    super(tt.let);
    this.name = name;
    this.init = init;
  }
}
export const varstmt = (name: Sym, init: Expr) => (
  new VariableStmt(name, init)
);

export class FunctionStmt extends Statement {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.functionStmt(this);
  }
  name: string;
  params: Sym[];
  body: Statement;
  constructor(
    name: string,
    params: Sym[],
    body: Statement,
  ) {
    super(tt.fn);
    this.name = name;
    this.params = params;
    this.body = body;
  }
}
export const fnStmt = (
  name: string,
  params: Sym[],
  body: Statement,
) => (
  new FunctionStmt(name, params, body)
);

export class ExprStmt extends Statement {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.exprStmt(this);
  }
  expr: Expr;
  constructor(expr: Expr) {
    super(expr.kind);
    this.expr = expr;
  }
}
export const exprStmt = (expr: Expr) => (
  new ExprStmt(expr)
);

export class BlockStmt extends Statement {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.blockStmt(this);
  }
  stmts: Statement[];
  constructor(stmts: Statement[]) {
    super(tt.begin);
    this.stmts = stmts;
  }
}
export const block = (statements: Statement[]) => (
  new BlockStmt(statements)
);

export abstract class Expr extends ASTNode {
  constructor(
    type: tt,
    nodeclass: nk.algebraic_expression | nk.nonalgebraic_expression,
  ) {
    super(type, nodeclass);
  }
}
export const isExpr = (node: ASTNode): node is Expr => (
  node.nodeclass === nk.algebraic_expression ||
  node.nodeclass === nk.nonalgebraic_expression
);

export abstract class NonalgebraicExpr extends Expr {
  constructor(type: tt) {
    super(type, nk.nonalgebraic_expression);
  }
}

export class FnCall extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.fnCall(this);
  }
  callee: Expr;
  args: Expr[];
  constructor(callee: Expr, args: Expr[]) {
    super(tt.rparen);
    this.callee = callee;
    this.args = args;
  }
}
export const fnCall = (callee: Expr, args: Expr[]) => (
  new FnCall(callee, args)
);

export class Atom extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.constant(this);
  }
  s: string | null | boolean;
  type: tt.string | tt.null | tt.bool;
  constructor(s: string | null | boolean, type: tt.string | tt.null | tt.bool) {
    super(type);
    this.s = s;
    this.type = type;
  }
}
export const str = (value: string) => (
  new Atom(value, tt.string)
);
export const nil = () => (
  new Atom(null, tt.null)
);

export const bool = (value: boolean) => (
  new Atom(value, tt.bool)
);

export class AssignExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.assign(this);
  }
  name: Sym;
  init: Expr;
  constructor(name: Sym, init: Expr) {
    super(tt.eq);
    this.name = name;
    this.init = init;
  }
}
export const assignment = (name: Sym, init: Expr) => (
  new AssignExpr(name, init)
);

export class LogicalExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.logicExpr(this);
  }
  left: Expr;
  op: Token<BooleanOperator>;
  right: Expr;
  constructor(left: Expr, op: Token<BooleanOperator>, right: Expr) {
    super(op.type);
    this.left = left;
    this.op = op;
    this.right = right;
  }
}
export const logic = (left: Expr, op: Token<BooleanOperator>, right: Expr) => (
  new LogicalExpr(left, op, right)
);

export class RelationExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.relation(this);
  }
  left: Expr;
  op: Token<RelationalOperator>;
  right: Expr;
  constructor(left: Expr, op: Token<RelationalOperator>, right: Expr) {
    super(op.type);
    this.left = left;
    this.op = op;
    this.right = right;
  }
}

export class SetExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.set(this);
  }
  elements: Expr[];
  constructor(elements: Expr[]) {
    super(tt.lbrace);
    this.elements = elements;
  }
}
export const setExpr = (elements: Expr[]) => (
  new SetExpr(elements)
);

export class TupleExpr extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.tuple(this);
  }
  elements: Expr[];
  constructor(elements: Expr[]) {
    super(tt.lbracket);
    this.elements = elements;
  }
}
export const tupleExpr = (elements: Expr[]) => (
  new TupleExpr(elements)
);

export class Group extends NonalgebraicExpr {
  accept<T>(visitor: Visitor<T>): T {
    return visitor.group(this);
  }
  expression: NonalgebraicExpr;
  constructor(expression: NonalgebraicExpr) {
    super(tt.lparen);
    this.expression = expression;
  }
}
export const group = (expr: NonalgebraicExpr) => (
  new Group(expr)
);

export const relation = (
  left: Expr,
  op: Token<RelationalOperator>,
  right: Expr,
) => (
  new RelationExpr(left, op, right)
);

export abstract class AlgebraicExpr extends Expr {
  abstract map<T>(algebra: Algebra<T>): T;
  constructor(type: tt) {
    super(type, nk.algebraic_expression);
  }
  abstract toString(): string;
}

export const sortArgs = (args: AlgebraicExpr[]) => (
  args.sort((a, b) => a.toString() < b.toString() ? -1 : 1)
);

export class Cmpx extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.complex(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.complex(this);
  }
  complex: Complex;
  constructor(c: Complex) {
    super(tt.complex);
    this.complex = c;
  }
  toString(): string {
    return this.complex.toString();
  }
}
export const cmpx = (c: Complex) => (
  new Cmpx(c)
);

export const isComplex = (n: AlgebraicExpr): n is Cmpx => (
  n.kind === tt.complex
);

export class Rational extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.rational(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.rational(this);
  }
  fraction: Fraction;
  constructor(f: Fraction) {
    super(tt.frac);
    this.fraction = f;
  }
  toString(): string {
    return this.fraction.toString();
  }
}
export const rational = (f: Fraction) => (
  new Rational(f)
);

export const isRational = (n: AlgebraicExpr): n is Rational => (
  n.kind === tt.frac
);

export class Float extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.float(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.float(this);
  }
  n: number;
  constructor(n: number) {
    super(tt.float);
    this.n = n;
  }
  toString(): string {
    return `${this.n}`;
  }
  get complex() {
    return complex([this.n, 0]);
  }
  get fraction() {
    return frac(toFrac(this.n));
  }
  get is0() {
    return this.n === 0;
  }
  get is1() {
    return this.n === 1;
  }
}
export const isFloat = (node: ASTNode): node is Float => (
  node.kind === tt.float
);
export const float = (value: string | number) => (
  new Float(+value)
);

export class Integer extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.int(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.int(this);
  }
  toString(): string {
    return `${this.n}`;
  }
  n: number;
  constructor(value: number) {
    super(tt.int);
    this.n = value;
  }
  get complex() {
    return complex([this.n, 0]);
  }
  get fraction() {
    return frac([this.n, 1]);
  }
  get is1() {
    return this.n === 1;
  }
  get is0() {
    return this.n === 0;
  }
}
export const isInteger = (node: ASTNode): node is Integer => (
  node.kind === tt.int
);
export const int = (value: number | string) => (
  new Integer(floor(+value))
);

export class Sym extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.symbol(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.symbol(this);
  }
  toString(): string {
    return this.s;
  }
  s: string;
  type: string;
  constructor(value: string, type: string) {
    super(tt.symbol);
    this.s = value;
    this.type = type;
  }
  equals(other: Sym) {
    return this.s === other.s;
  }
  entype(type: string) {
    return new Sym(
      this.s,
      type,
    );
  }
}
export const sym = (value: string, type: string = "") => (
  new Sym(value, type)
);
export const isSymbol = (node: ASTNode): node is Sym => (
  node.kind === tt.symbol
);

export class AlgebraicGroup extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.algebraicGroup(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.algebraicGroup(this);
  }
  toString(): string {
    return `(${this.expression.toString()})`;
  }
  expression: AlgebraicExpr;
  constructor(expression: AlgebraicExpr) {
    super(tt.lparen);
    this.expression = expression;
  }
}
export const isparend = (n: AlgebraicExpr): n is AlgebraicGroup => (
  n.kind === tt.lparen && n.nodeclass === nk.algebraic_expression
);
export const algebraGroup = (expression: AlgebraicExpr) => (
  new AlgebraicGroup(expression)
);

export class AlgebraicCall<F extends CoreFns = CoreFns> extends AlgebraicExpr {
  map<T>(algebra: Algebra<T>): T {
    return algebra.algebraicCall(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.algebraicCall(this);
  }
  toString(): string {
    return `${this.callee}(${this.args.map((v) => v.toString()).join(",")})`;
  }
  callee: F;
  args: AlgebraicExpr[];
  constructor(callee: F, args: AlgebraicExpr[]) {
    super(tt.call);
    this.callee = callee;
    this.args = args;
  }
  isSin() {
    return this.callee === "sin";
  }
  isCos() {
    return this.callee === "cos";
  }
  isTan() {
    return this.callee === "tan";
  }
  isArcTan() {
    return this.callee === "arctan";
  }
  isSum() {
    return this.callee === "+";
  }
  isDiff() {
    return this.callee === "-";
  }
  isFactorial() {
    return this.callee === "!";
  }
  isNeg() {
    return this.callee === "neg";
  }
  isPos() {
    return this.callee === "+";
  }
  isProd() {
    return this.callee === "*";
  }
}

export type CoreFns =
  | "sin"
  | "cos"
  | "tan"
  | "arctan"
  | "+"
  | "-"
  | "!"
  | "*"
  | "neg"
  | "pos";
export const isAlgebraicCall = (n: AlgebraicExpr): n is AlgebraicCall => (
  n.kind === tt.call && n.nodeclass === nk.algebraic_expression
);
export const algebraCall = (callee: CoreFns, args: AlgebraicExpr[]) => {
  return new AlgebraicCall(callee, args);
};
export const flatten = (op: CoreFns, args: AlgebraicExpr[]) => {
  const newargs = [];
  if (op !== "+" && op !== "*") {
    return args;
  }
  for (let i = 0; i < args.length; i++) {
    const n = args[i];
    if (isAlgebraicCall(n) && n.callee === op) {
      n.args.forEach((a) => newargs.push(a));
      continue;
    }
    newargs.push(n);
  }
  return newargs;
};

export type AX = AlgebraicExpr;
export type BinarySum = Binary<AX, tt.plus, AX>;
export type BinaryProduct = Binary<AX, tt.star, AX>;
export type BinaryDiff = Binary<AX, tt.minus, AX>;
export type BinaryQuot = Binary<AX, tt.slash, AX>;
export type BinaryPow = Binary<AX, tt.caret, AX>;

export class Binary<
  A extends AlgebraicExpr = AlgebraicExpr,
  O extends BinaryOperator = BinaryOperator,
  B extends AlgebraicExpr = AlgebraicExpr,
> extends AlgebraicExpr {
  toString(): string {
    return `${this.left.toString()} ${this.op.lex} ${this.right.toString()}`;
  }
  map<T>(algebra: Algebra<T>): T {
    return algebra.binary(this);
  }
  accept<T>(visitor: Visitor<T>): T {
    return visitor.binary(this);
  }
  toSum() {
    return new AlgebraicCall("+", sortArgs([this.left, this.right]));
  }
  toProduct() {
    return new AlgebraicCall("*", sortArgs([this.left, this.right]));
  }
  left: A;
  op: Token<O>;
  right: B;
  constructor(
    left: A,
    op: Token<O>,
    right: B,
  ) {
    super(op.type);
    this.left = left;
    this.op = op;
    this.right = right;
  }
  isPow(): this is BinaryPow {
    return this.op.is(tt.caret as any);
  }
  isProd(): this is BinaryProduct {
    return this.op.is(tt.star as any);
  }
  isQuot(): this is BinaryQuot {
    return this.op.is(tt.slash as any);
  }
  isDiff(): this is BinaryDiff {
    return this.op.is(tt.minus as any);
  }
  isSum(): this is BinarySum {
    return this.op.is(tt.plus as any);
  }
  static sum(left: AlgebraicExpr, right: AlgebraicExpr) {
    return new Binary(left, tkn(tt.plus, "+", -1), right);
  }
  static product(left: AlgebraicExpr, right: AlgebraicExpr) {
    return new Binary(left, tkn(tt.star, "*", -1), right);
  }
}

export const isBinary = (node: ASTNode): node is Binary => (
  node.nodeclass === nk.algebraic_expression && (
    node.kind === tt.star ||
    node.kind === tt.plus ||
    node.kind === tt.caret ||
    node.kind === tt.slash ||
    node.kind === tt.mod ||
    node.kind === tt.percent
  )
);
export const binex = (
  left: AlgebraicExpr,
  op: Token<BinaryOperator>,
  right: AlgebraicExpr,
) => (
  new Binary(left, op, right)
);

export class Program {
  code: Statement[];
  error: Err | null;
  constructor(code: Statement[], error: Err | null) {
    this.code = code;
    this.error = error;
  }
}
export const success = (code: Statement[]) => (
  new Program(code, null)
);
export const failure = (error: Err) => (
  new Program([], error)
);


const head = (n: EXPR) => n[0];
type INT = ["int", number];
const nInt = (n: number): INT => ["int", n];
const isint = (n: EXPR): n is INT => head(n) === "int";

type COMPLEX = ["complex", Complex];
const nComplex = (n: Complex): COMPLEX => ["complex", n];
const iscomplex = (n: EXPR): n is COMPLEX => head(n) === "complex";

type FRACTION = ["fraction", Fraction];
const nFrac = (n: Fraction): FRACTION => ["fraction", n];
const isfrac = (n: EXPR): n is FRACTION => head(n) === "fraction";

type FLOAT = ["float", number];
const nFloat = (n: number): FLOAT => ["float", n];
const isfloat = (n: EXPR): n is FLOAT => head(n) === "float";

type SYM = ["symbol", string];
const nSym = (n: string): SYM => ["symbol", n];
const issym = (n: EXPR): n is SYM => head(n) === "symbol";

type SUM = ["+", EXPR[]];
const nSum = (args: EXPR[]): SUM => ["+", args];
const issum = (n: EXPR): n is SUM => head(n) === "+";

type PRODUCT = ["*", EXPR[]];
const nProd = (args: EXPR[]): PRODUCT => ["*", args];
const isprod = (n: EXPR): n is PRODUCT => head(n) === "*";

type DIFFERENCE = ["-", EXPR[]];
const nDiff = (args: EXPR[]): DIFFERENCE => ["-", args];
const isdiff = (n: EXPR): n is DIFFERENCE => head(n) === "-";

type QUOTIENT = ["/", EXPR[]];
const nQuot = (args: EXPR[]): QUOTIENT => ["/", args];
const isquot = (n: EXPR): n is QUOTIENT => head(n) === "/";

type POWER = ["^", EXPR[]];
const nPow = (args: EXPR[]): POWER => ["^", args];
const ispow = (n: EXPR): n is POWER => head(n) === "^";

type FACTORIAL = ["!", EXPR[]];
const nFact = (args: EXPR[]): FACTORIAL => ["!", args];
const isfact = (n: EXPR): n is FACTORIAL => head(n) === "!";

type FUN = [`fun-${string}`, EXPR[]];
const fun = (name: string, args: EXPR[]): FUN => [`fun-${name}`, args];
const nFun = (n: EXPR): n is FUN => head(n).startsWith("fun");

type ERR = ["error", string];
const error = (message: string): ERR => ["error", message];
const iserror = (n: EXPR): n is ERR => head(n) === "error";

type ATOM = INT | FLOAT | SYM;
type EXPR =
  | ATOM
  | SUM
  | PRODUCT
  | DIFFERENCE
  | POWER
  | QUOTIENT
  | FACTORIAL
  | FUN
  | COMPLEX
  | FRACTION
  | ERR;

class Reducer implements Visitor<EXPR> {
  ap(node: ASTNode) {
    return node.accept(this);
  }
  int(node: Integer): EXPR {
    return nInt(node.n);
  }
  symbol(node: Sym): EXPR {
    return nSym(node.s);
  }
  float(node: Float): EXPR {
    return nFloat(node.n);
  }
  complex(node: Cmpx): EXPR {
    return nComplex(node.complex);
  }
  rational(node: Rational): EXPR {
    return nFrac(node.fraction);
  }
  constant(node: Atom): EXPR {
    return error(`Encountered non-algebraic node: constant`);
  }
  binary(node: Binary): EXPR {
    const left = this.ap(node.left);
    if (iserror(left)) return left;
    const right = this.ap(node.right);
    if (iserror(right)) return right;
    const op = node.op;
    if (issum(left) && issum(right)) {
      return nSum([...left[1], ...right[1]])
    }
    switch (op.type) {
      case tt.plus: {
        if (isint(left) && isint(right)) {
          return nInt(left[1] + right[1]);
        }
        return nSum([left, right]);
      }
      case tt.minus: {
        if (isint(left) && isint(right)) {
          return nInt(left[1] - right[1]);
        }
        return nDiff([left, right]);
      }
      case tt.star: {
        if (isint(left) && isint(right)) {
          return nInt(left[1] * right[1]);
        }
        return nProd([left, right]);
      }
      case tt.caret: {
        if (isint(left) && isint(right)) {
          return nInt(left[1] ** right[1]);
        }
        return nPow([left, right]);
      }
      case tt.slash: {
        if (isint(left) && isint(right)) {
          return nFrac(frac([left[1], right[1]]));
        }
        return nQuot([left, right]);
      }
    }
    return error(`Unhandled op:${node.op.lex}`);
  }
  tuple(node: TupleExpr): EXPR {
    return error(`Encountered non-algebraic node: tuple`);
  }
  fnCall(node: FnCall): EXPR {
    return error(`Encountered non-algebraic node: call`);
  }
  set(node: SetExpr): EXPR {
    return error(`Encountered non-algebraic node: set`);
  }
  relation(node: RelationExpr): EXPR {
    return error(`Encountered non-algebraic node: relation`);
  }
  logicExpr(node: LogicalExpr): EXPR {
    return error(`Encountered non-algebraic node: logic`);
  }
  group(node: Group): EXPR {
    return this.ap(node.expression);
  }
  assign(node: AssignExpr): EXPR {
    return error(`Encountered non-algebraic node: assign`);
  }
  blockStmt(node: BlockStmt): EXPR {
    return error(`Encountered non-algebraic node: block`);
  }
  exprStmt(node: ExprStmt): EXPR {
    return error(`Encountered non-algebraic node: expr-stmt`);
  }
  functionStmt(node: FunctionStmt): EXPR {
    return error(`Encountered non-algebraic node: fn-stmt`);
  }
  ifStmt(node: IfStmt): EXPR {
    return error(`Encountered non-algebraic node: if-stmt`);
  }
  varStmt(node: VariableStmt): EXPR {
    return error(`Encountered non-algebraic node: var-stmt`);
  }
  loopStmt(node: LoopStmt): EXPR {
    return error(`Encountered non-algebraic node: loop-stmt`);
  }
  run(node: ParsedExpr) {
    if (node.isLeft()) return error(node.unwrap().message);
    return this.ap(node.unwrap());
  }
}

const tidy = (node: ParsedExpr) => {
  const out = new Reducer().run(node);
  return out;
};
class AlgebraTree implements Visitor<Left<Err> | Right<AlgebraicExpr>> {
  error: Err | null = null;
  ap(node: ASTNode) {
    if (this.error !== null) {
      return this.error;
    }
    const out = node.accept(this);
    if (iserr(out)) {
      this.error = out;
      return left(out);
    }
    return out;
  }
  int(node: Integer): Right<$Integer> {
    return right(int(node.n));
  }
  symbol(node: Sym): Right<$Symbol> {
    return right(sym(node.s));
  }
  float(node: Float): Left<Err> {
    return left(
      algebraError(
        `Floats are not currently supported in the algebra runtime.`,
      ),
    );
  }
  constant(node: Literal): Left<Err> {
    return left(
      algebraError(
        `Type “${node.typeof()}” is not currently supported in the algebra runtime.`,
      ),
    );
  }
  binary(node: Binary) {
    const left = this.ap(node.left);
    const right = this.ap(node.right);
    switch (node.op.type) {
      case tt.plus: {
        if (isfrac(left) && isfrac(right)) {
          return nFrac(left.x.add(right.x));
        } else if (isint(left) && isint(right)) {
          return int(left.x + right.x);
        } else if (issum(left) && issum(right)) {
          const args = [...left.args, ...right.args];
          return sum(args);
        } else if (issum(left)) {
          const args = [...left.args, right];
          return sum(args);
        } else if (issum(right)) {
          return sum([left, ...right.args]);
        } else {
          return sum([left, right]);
        }
      }
      case tt.minus:
        if (isfrac(left) && isfrac(right)) {
          return nFrac(left.x.sub(right.x));
        } else if (isint(left) && isint(right)) {
          return int(left.x - right.x);
        } else {
          return diff([left, right]);
        }
      case tt.star: {
        if (isfrac(left) && isfrac(right)) {
          return nFrac(left.x.mul(right.x));
        } else if (isint(left) && isint(right)) {
          return int(left.x * right.x);
        } else if (isprod(left) && isprod(right)) {
          return product([...left.args, ...right.args]);
        } else if (isprod(left)) {
          return product([...left.args, right]);
        } else if (isprod(right)) {
          return product([left, ...right.args]);
        } else if (issum(left)) {
          return left.distribute(right);
        } else if (
          ispow(left) && ispow(right) && left.base.equals(right.base)
        ) {
          return power([
            left.base,
            sum([...left.args.slice(1), ...right.args.slice(1)]),
          ]);
        } else {
          return product([left, right]);
        }
      }
      case tt.slash: {
        if (isint(left) && isint(right) && right.x !== 0) {
          return nFrac([left.x, right.x]);
        } else {
          const n = left;
          const d = power([right, int(-1)]);
          return product([n, d]);
        }
      }

      case tt.caret: {
        if (isint(left) && isint(right)) {
          return int(left.x ** right.x);
        } /**
         * Rule: If u = v^n and n is an integer,
         * then v cannot be an int, product, power.
         */
        // hence:
        else if (
          (isfrac(left) || isprod(left) || ispow(left)) && isint(right)
        ) {
          const n = right.x;
          const res = ntimes(n, left);
          if (res._tag === "None") {
            return nErr(`Error while evaluating “^” for fractions.`);
          }
        } else if (ispow(left)) {
          // (a^m)^n -> a^(m * n)
          const a = left.base;
          const apow = left.args.slice(1);
          const exp = right;
          return power([a, product([...apow, exp])]);
        } // (ab)^n -> (^ (a * b) n) -> (a^n * b^n)
        else if (isprod(left)) {
          const l = left;
          const exp = right;
          const args = raise(l.args, exp);
          return product(args);
        } else {
          return power([left, right]);
        }
      }
    }
    return nErr(`Invalid operand`);
  }
  fnCall(node: FnCall) {
    if (node.native) {
      const args = node.args.map((a) => this.ap(a));
      const name = (node.callee as Sym).s;
      return right(fun(name, args));
    }
    return left(algebraError(`Call to a non-algebraic function.`));
  }
  relation(node: RelationExpr) {
    return left(
      algebraError(
        `Relations are not currently supported by the algebra runtime.`,
      ),
    );
  }
  logicExpr(node: LogicalExpr) {
    return left(
      algebraError(
        `Logical expressions are not currently supported by the algebra runtime.`,
      ),
    );
  }
  group(node: Group) {
    throw new Error('')
    // const n = this.ap(node.expression);
    // return n.tickParen();
  }
  assign(node: AssignExpr) {
    throw new Error('')
  }
  blockStmt(node: BlockStmt) {
    throw new Error('')
  }
  exprStmt(node: ExprStmt) {
    throw new Error('')
  }
  functionStmt(node: FunctionStmt) {
    throw new Error('')
  }
  ifStmt(node: IfStmt) {
    throw new Error('')
  }
  varStmt(node: VariableStmt) {
    throw new Error('')
  }
  loopStmt(node: LoopStmt) {
    throw new Error('')
  }
  reduce(node: Maybe<Expr>) {
    return node.map((x) => this.ap(x));
  }
}
const algebraTree = (expr: Maybe<Expr>) => (
  new AlgebraTree().reduce(expr)
);

const sortargs = (nodes: AlgebraicExpr[]) => (
  [...nodes].sort((a, b) => a.toString() < b.toString() ? -1 : 1)
);

const freeof = (expr: AlgebraicExpr, t: AlgebraicExpr) => {
  const f = (u: AlgebraicExpr) => {
    if (u.equals(t)) return false;
    else if (isatom(u)) return true;
    else {
      let i = 0;
      while (i <= u.opcount()!) {
        if (!isCompound(u)) return false;
        const op = u.operand(i);
        if (!f(op)) return false;
        i = i + 1;
      }
      return true;
    }
  };
  return f(expr);
};

const subexpressions = (expr: AlgebraicExpr) => {
  const out: AlgebraicExpr[] = [];
  const f = (e: AlgebraicExpr | null) => {
    if (e === null) return;
    if (isatom(e)) {
      out.push(e);
      return null;
    } else if (e instanceof CompoundExpr) {
      out.push(e);
      e.args.forEach((x) => f(x));
      return null;
    } else if (isfun(e)) {
      out.push(e);
      e.args.forEach((x) => f(x));
      return null;
    }
    return null;
  };
  f(expr);
  return out;
};

/**
 * Determines the given algebraic expression
 * has the form `ax + b`, where the expressions
 * `a` and `b` are free of x.
 */
export const linearForm = (e: AlgebraicExpr, x: Sym) => {
  let f: Maybe<any> = none();
  let r: Maybe<any> = none();
  const fn = (u: AlgebraicExpr) => {
    print(u);
    if (u.equals(x)) {
      return some([int(1), int(0)]);
    } else if (isatom(u)) {
      return some([int(0), u]);
    } else if (isprod(u)) {
      if (freeof(u, x)) {
        return some([int(0), u]);
      } else if (freeof(quotient([u, x]), x)) {
        return some([quotient([u, x]), int(0)]);
      } else {
        return none();
      }
    } else if (issum(u)) {
      f = fn(u.operand(1));
      if (f._tag === "None") return none();
      else {
        r = fn(diff([u, u.operand(1)]));
        if (r._tag === "None") return none();
        else {
          const F: CompoundExpr = (f as Some<CompoundExpr>).value;
          const R: CompoundExpr = (r as Some<CompoundExpr>).value;
          return some([
            sum([F.operand(1), R.operand(1)]),
            sum([F.operand(2), R.operand(2)]),
          ]);
        }
      }
    } else if (freeof(u, x)) {
      return some([int(0), x]);
    } else {
      return none();
    }
  };
  return fn(e);
};

export const raise = (exprs: AlgebraicExpr[], exponent: AlgebraicExpr) => {
  const out = exprs.map((n) => power([n, exponent]));
  return out;
};

/**
 * Returns an n-ary product of the given
 * expression.
 */
export const ntimes = (n: number, expr: AlgebraicExpr) => {
  if (n < 0) {
    return none();
  }
  if (n <= 0) {
    return some(product([int(1), expr]));
  }
  const args: AlgebraicExpr[] = [];
  for (let i = 0; i < n; i++) {
    args.push(expr.copy());
  }
  return some(product(args));
};

interface AlgebraVisitor<T> {
  int(int: Int): T;
  sym(sym: Sym): T;
  diff(diff: Difference): T;
  quotient(quot: Quotient): T;
  sum(sum: Sum): T;
  product(product: Product): T;
  power(power: Power): T;
  factorial(factorial: Factorial): T;
  func(fn: FunctionCall): T;
  fraction(fraction: Fractional): T;
}

enum op {
  int = "int",
  symbol = "symbol",
  fraction = "fraction",
  fun = "fun",
  power = "^",
  factorial = "!",
  sum = "+",
  product = "*",
  diff = "-",
  quot = "/",
}

export abstract class AlgebraicExpr {
  op: op;
  parenLevel: number = 0;
  abstract accept<T>(visitor: AlgebraVisitor<T>): T;
  constructor(op: op) {
    this.op = op;
  }
  tickParen() {
    this.parenLevel++;
    return this;
  }
  abstract copy(): AlgebraicExpr;
  abstract seqmap(pairs: ([AlgebraicExpr, AlgebraicExpr])[]): AlgebraicExpr;
  abstract substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr;
  abstract toString(): string;
  abstract equals(expr: AlgebraicExpr): boolean;
  abstract opcount(): Some<number> | None;
  abstract freeof(expr: AlgebraicExpr): boolean;
}

const nType =
  <T extends AlgebraicExpr>(op: op) => (node: AlgebraicExpr): node is T => (
    node.op === op
  );

type Prim = string | number | Fraction;

export abstract class Atom<X extends Prim = Prim> extends AlgebraicExpr {
  op: op.int | op.symbol | op.fraction;
  x: X;
  constructor(x: X, op: op.int | op.symbol | op.fraction) {
    super(op);
    this.op = op;
    this.x = x;
  }
  equals(expr: AlgebraicExpr): boolean {
    if (!(expr instanceof Atom)) return false;
    if (this.x instanceof Fraction) {
      if (expr.x instanceof Fraction) {
        const [t, u] = simplify([this.x.n, this.x.d]);
        const [v, w] = simplify([this.x.n, this.x.d]);
        return (t === v) && (u === w);
      } else if (typeof expr.x === "number") {
        const [n, d] = toFrac(expr.x);
        return (n === this.x.n) && (d === this.x.d);
      } else if (typeof expr.x === "string") {
        return (this.x.toString() === expr.x);
      }
    }
    return expr.x === this.x;
  }
  toString(): string {
    return `${this.x.toString()}`;
  }
  opcount() {
    return none();
  }
  freeof(expr: AlgebraicExpr): boolean {
    return !this.equals(expr);
  }
  substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr {
    return this.equals(expr) ? b : this;
  }
  seqmap(pairs: [AlgebraicExpr, AlgebraicExpr][]): AlgebraicExpr {
    for (let i = 0; i < pairs.length; i++) {
      const [a, b] = pairs[i];
      if (this.equals(a)) return b;
    }
    return this;
  }
}

export const isatom = (n: AlgebraicExpr): n is Atom => (
  n.op === op.symbol ||
  n.op === op.int ||
  n.op === op.fraction
);

export class Fractional extends Atom {
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.fraction(this);
  }
  copy(): Fractional {
    return new Fractional(this.x.copy());
  }
  x: Fraction;
  constructor(f: Fraction) {
    super(f, op.fraction);
    this.x = f;
  }
}

export const nFrac = (xs: [number, number] | Fraction) => (
  new Fractional(isarray(xs) ? Fraction.from(xs) : xs)
);
export const isfrac = nType<Atom<Fraction>>(op.fraction);

export class Int extends Atom {
  x: number;
  constructor(n: number) {
    super(n, op.int);
    this.x = n;
  }
  copy(): Int {
    return new Int(this.x);
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.int(this);
  }
}
export const isint = nType<Atom<number>>(op.int);

export const int = (n: number) => (
  new Int(n)
);

export class Sym extends Atom {
  x: string;
  constructor(s: string) {
    super(s, op.symbol);
    this.x = s;
  }
  copy(): Sym {
    return new Sym(this.x);
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.sym(this);
  }
}

export const issym = nType<Atom<string>>(op.symbol);

export const sym = (n: string) => (
  new Sym(n)
);

export abstract class CompoundExpr extends AlgebraicExpr {
  args: AlgebraicExpr[];
  constructor(op: op, args: AlgebraicExpr[]) {
    super(op);
    this.args = args;
  }
  equals(expr: AlgebraicExpr): boolean {
    if (!(expr instanceof CompoundExpr)) return false;
    if (expr.args.length !== this.args.length) return false;
    if (this.op !== expr.op) return false;
    const ns = expr.args.reduce((p, c, i) => p && c.equals(this.args[i]), true);
    return ns;
  }
  opcount() {
    return some(this.args.length);
  }
  freeof(expr: AlgebraicExpr): boolean {
    return this.args.reduce((p, c) => p && c.freeof(expr), true);
  }
  operand(i: number) {
    const out = this.args[i];
    if (out === undefined) return sym("undefined");
    return out;
  }
}

export class Difference extends CompoundExpr {
  constructor(args: AlgebraicExpr[]) {
    super(op.diff, args);
  }
  copy(): Difference {
    const args = this.args.map((v) => v.copy());
    return new Difference(args);
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.diff(this);
  }
  toString(): string {
    const ls = this.args.map((n) => n.toString());
    return ls.join("-");
  }
  substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr {
    const out = this.args.map((a) => a.substitute(expr, b));
    return diff(out);
  }
  seqmap(pairs: [AlgebraicExpr, AlgebraicExpr][]): AlgebraicExpr {
    const out = this.args.map((a) => a.seqmap(pairs));
    return diff(out);
  }
}

export const isdiff = nType<Difference>(op.diff);

export const diff = (args: AlgebraicExpr[]) => (
  new Difference(args)
);

export class Quotient extends CompoundExpr {
  constructor(args: AlgebraicExpr[]) {
    super(op.quot, args);
  }
  copy(): Quotient {
    const args = this.args.map((a) => a.copy());
    const out = new Quotient(args);
    out.parenLevel = this.parenLevel;
    return out;
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.quotient(this);
  }
  toString(): string {
    const ls = this.args.map((n) => n.toString());
    return ls.join("/");
  }

  substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr {
    const args = this.args.map((a) => a.substitute(expr, b));
    return quotient(args);
  }
  seqmap(pairs: [AlgebraicExpr, AlgebraicExpr][]): AlgebraicExpr {
    const args = this.args.map((a) => a.seqmap(pairs));
    return quotient(args);
  }
}
export const isquot = nType<Quotient>(op.quot);
export const isCompound = (node: AlgebraicExpr): node is CompoundExpr => (
  !isatom(node)
);
export const quotient = (args: AlgebraicExpr[]) => (
  new Quotient(args)
);

export class Sum extends CompoundExpr {
  constructor(args: AlgebraicExpr[]) {
    super(op.sum, args);
  }
  copy(): Sum {
    const args = this.args.map((a) => a.copy());
    const out = sum(args);
    out.parenLevel = this.parenLevel;
    return out;
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.sum(this);
  }
  toString(): string {
    const ls = this.args.map((n) => n.toString());
    return ls.join("+");
  }
  substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr {
    const args = this.args.map((a) => a.substitute(expr, b));
    return sum(args);
  }
  distribute(expr: AlgebraicExpr) {
    const out: AlgebraicExpr[] = [];
    for (let i = 0; i < this.args.length; i++) {
      out.push(product([expr, this.args[i]]));
    }
    return sum(out);
  }
  seqmap(pairs: [AlgebraicExpr, AlgebraicExpr][]): AlgebraicExpr {
    const args = this.args.map((a) => a.seqmap(pairs));
    return sum(args);
  }
}

export const sum = (args: AlgebraicExpr[]) => (
  new Sum(args)
);

export const issum = nType<Sum>(op.sum);

export class Product extends CompoundExpr {
  constructor(args: AlgebraicExpr[]) {
    super(op.product, args);
  }
  copy(): Product {
    const args = this.args.map((a) => a.copy());
    const out = product(args);
    out.parenLevel = this.parenLevel;
    return out;
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.product(this);
  }
  toString(): string {
    const ls = this.args.map((n) => n.toString());
    return ls.join("*");
  }
  substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr {
    const args = this.args.map((a) => a.substitute(expr, b));
    return product(args);
  }
  seqmap(pairs: [AlgebraicExpr, AlgebraicExpr][]): AlgebraicExpr {
    const args = this.args.map((n) => n.seqmap(pairs));
    return product(args);
  }
}
export const product = (args: AlgebraicExpr[]) => {
  return new Product(args);
};

export const isprod = nType<Product>(op.product);

export class Power extends CompoundExpr {
  args: AlgebraicExpr[];
  constructor(args: AlgebraicExpr[]) {
    super(op.power, args);
    this.args = args;
  }
  copy(): AlgebraicExpr {
    const args = this.args.map((c) => c.copy());
    const out = power(args);
    out.parenLevel = this.parenLevel;
    return out;
  }
  get base() {
    return this.args[0];
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.power(this);
  }
  toString(): string {
    const ls = this.args.map((n) => n.toString());
    return ls.join("^");
  }
  substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr {
    const args = this.args.map((a) => a.substitute(expr, b));
    return power(args);
  }
  seqmap(pairs: [AlgebraicExpr, AlgebraicExpr][]): AlgebraicExpr {
    const args = this.args.map((n) => n.seqmap(pairs));
    return power(args);
  }
}
export const power = (args: AlgebraicExpr[]) => (
  new Power(args)
);

export const ispow = nType<Power>(op.power);

export class Factorial extends CompoundExpr {
  constructor(args: AlgebraicExpr[]) {
    super(op.factorial, args);
  }
  copy(): AlgebraicExpr {
    const args = this.args.map((a) => a.copy());
    const out = factorial(args);
    out.parenLevel = this.parenLevel;
    return out;
  }
  seqmap(pairs: [AlgebraicExpr, AlgebraicExpr][]): AlgebraicExpr {
    const args = this.args.map((p) => p.seqmap(pairs));
    return factorial(args);
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.factorial(this);
  }
  toString(): string {
    const ls = this.args.map((n) => n.toString());
    return ls.join("") + "!";
  }
  substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr {
    const as = this.args.map((n) => n.substitute(expr, b));
    return factorial(as);
  }
}
export const factorial = (args: AlgebraicExpr[]) => (
  new Factorial(args)
);

export const isfact = nType<Factorial>(op.factorial);

export class FunctionCall extends AlgebraicExpr {
  name: string;
  args: AlgebraicExpr[];
  constructor(name: string, args: AlgebraicExpr[]) {
    super(op.fun);
    this.name = name;
    this.args = args;
  }
  copy(): AlgebraicExpr {
    const name = this.name;
    const args = this.args.map((a) => a.copy());
    return fun(name, args);
  }
  seqmap(pairs: [AlgebraicExpr, AlgebraicExpr][]): AlgebraicExpr {
    const args = this.args.map((p) => p.seqmap(pairs));
    return fun(this.name, args);
  }
  freeof(expr: AlgebraicExpr): boolean {
    return this.args.reduce((p, c) => p && c.freeof(expr), true);
  }
  substitute(expr: AlgebraicExpr, b: AlgebraicExpr): AlgebraicExpr {
    return this.equals(expr) ? b : this;
  }
  opcount(): number {
    return some(this.args.length);
  }
  equals(expr: AlgebraicExpr): boolean {
    if (!(expr instanceof FunctionCall)) return false;
    if (expr.name !== this.name) return false;
    if (this.args.length !== expr.args.length) return false;
    const ns = expr.args.reduce((p, c, i) => p && c.equals(this.args[i]), true);
    return ns;
  }
  accept<T>(visitor: AlgebraVisitor<T>): T {
    return visitor.func(this);
  }
  toString(): string {
    const ls = this.args.map((n) => n.toString());
    return this.name + "(" + ls.join(",") + ")";
  }
}
export const fun = (name: string, args: AlgebraicExpr[]) => (
  new FunctionCall(name, args)
);

export const isfun = nType<FunctionCall>(op.fun);
